\documentclass[14pt]{extarticle}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{cite}
\usepackage{titlesec}
\usepackage{svg}
\usepackage{geometry}
\usepackage{indentfirst}
\usepackage{float}
\usepackage{xcolor}
\usepackage{soul}
\usepackage{extsizes}

\geometry{
    left=25mm,
    right=10mm,
    top=20mm,
    bottom=20mm
}

\linespread{1.3}

\def\labelitemi{$-$}

\title{Диплом}
\begin{document}


\maketitle

\pagebreak
\tableofcontents

\pagebreak
\section{Введение}

Компания «Институт Сетевых Технологий» существует на рынке более 20 лет и
занимается разработкой программных и аппаратно-программных средств связи,  телекоммуникационных и защищённых систем в интересах ВС РФ.

Основными продуктами компании являются:
\begin{itemize}
    \item Средства построения защищённых инфраструктур
    \subitem маршрутизатор доступа гарда 10g
    \subitem криптомаршрутизатор многопротокольный
    \subitem устройство уплотнения каналов «уук-512»
    \subitem межсетевой экран «тродос»
    \subitem система мониторинга и управления сетями и сервисами «нейрон»
    \item Средства телефонной и видеотелефонной связи
    \subitem сервер видеоконференцсвязи
    \subitem ПВТС — пакетная видеотелефонная и телефонная связь
    \subitem интегрированный терминал
    \item Аппаратно-програмные комплексы
    \subitem комплекс корабельной громкоговорящей связи «линия»
    \subitem многофункциональный абонентский терминал (МФАТ) «пеленг»
\end{itemize}

Компания самостоятельно разрабатывает  как аппаратную  архитектуру, так и програмное обеспечение, а так же занимается развёртыванием и сопровождением своих продуктов на объектах.

Основными заказщиками компании являются Министерство обороны РФ, ВМФ РФ, ФСО России и ряд крупных государственных компаний.

Компания успешно конкурирует на Российском рынке телекоммуникационных средств и систем с такими гигантами индрустрии как Cisco и Juniper.

Флагманским продуктом компании является Маршутизатор доступа (МД), который представляет из себя современный сетевой маршрутизатор. В качестве операционной системы он использует не всем привычный linux, а eCos.

Причём eCos не является операционной системой в привычном понимании этого термина Она похожа на библиотеку по тому, как она используется. Пользовательский код ссылается на функции из eCos. При сборке бинарные файлы eCos компануется (линкуется) с пользовательским кодом и загружается с помощью специального загрузчика RedBoot.

В МД реализовано множество сервисов, хорошо знакомым администраторам linux например (Web сервер, SSH сервер), однако DHCP сервер в МД не реализован. Поэтому для назначения IP адресов и других параметров использовались другие компьютеры с DHCP серверами, а на МД был запущен DHCP ретранслятор, выступающий роли посредника, между сервером и клиентами.

Так как протокол DHCP используется повсеместно, в МД так же появилась необходимость в реализации полноценного встроенного DHCP сервера.

\pagebreak
\section{Основная часть}

\subsection{Введение в Архитектуру ПО}

Програмная Архитектура МД - двухсойная.

1й слой отвечает за взаимодействие с железом. 2й за реализацию сетевых протоколов.
Есть три варианта 1го слоя.

\begin{itemize}
    \item для сборки под eCos и загрузки в маршрутизатор.
    \item для сборки под Linux на компьютере разработчика.
    \item для сборки под Windows на компьютере разработчика.
\end{itemize}

\begin{figure}[H]
    \includegraphics[width=\textwidth]{build/router-architecture.png}
    \caption{2й слой архитектуры}
\end{figure}

2й слой предоставляет для разработчика интерфейс, показанный на рисунке.
Есть модули, и объекты управления ими.

Для реализации DHCP сервера, будет добавлен один модуль и один объект управления.
Объект управления будет отвечать за настройки сервера, он будет работать, когда администратор захочет что нибудь изменить в настройках сервера.

Модуль сервера же, в свою очередь будет будет получать пакеты, формировать ответы, и отправлять их в сеть.

\subsection{Описание прикладного процесса}

Администратор подходит к компьютеру, открывает программу эмуляции терминала и вручную его настраивает
(задаёт IP адрес, прописывает маршруты, возможно что-то ещё).
Далее он подходит к следующему компьютеру и тоже его настраивает.

Для автоматизации данного процесса в современных сетях на базе IP используется протокол DHCP.

Его идея состоит в том, что при включении компьютер спрашивает путём широковещательного запроса, есть ли где нибудь DHCP сервера.
DHCP сервера слушают сеть на предмет таких запросов, и в ответе предлагают клиенту сконфигурированные администратором настройки.
DHCP серверов может быть несколько, а клиент выбирает только одного из них.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{build/dhcp-simple.png}
    \caption{}
\end{figure}

Но широковещательные пакеты не уходят за предел локальной сети.
Для того, чтобы DHCP сервер, находящийся за пределами локальной сети получал эти пакеты, следует использовать DHCP ретранслятор.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{build/relay-net.png}
    \caption{}
\end{figure}

Он ловит широковещятельные запросы и перенаправляет на заданный ему администратором IP адрес DHCP сервера.
Затем получает от сервера ответ и отправляет его клиенту.
Таким образом он служит в качестве посредника между сервером и клиентом.

Помимо этого ретранслятор может добавлять специальные опции в DHCP пакеты, которые могут быть использованы DHCP сервером для более точной идентификации клиента, или для предотвращения различных атак.


\begin{figure}[H]
    \centering
    \includegraphics[height=0.95\textheight]{build/dhcp-activity-relay.png}
    \caption{}
\end{figure}

\subsection{Постановка задачи}

\begin{itemize}
    \item Изучение RFC2131, RFC2132 и других RFC описывающих стандарт DHCP и различных опциональных параметров
    \item Изучение документации на уже существующие DHCP сервера (cisco, isc)
    \item Придумать, как сервер будет конфигурироваться
    \item Проектирование програмной архитектуры и архитектуры данных
    \item Разработка DHCP сервера
    \item Написание документации
\end{itemize}

Разработать DHCP сервер необходимо в виде 2х новых модулей модулей.
Один будет отвечать на запросы клиентов.
Второй же, в свою очередь будет отвечать за изменение настроек.

\subsection{Анализ существующих решений, обоснование выбора.}

Существует множество DHCP серверов с открытым исходным кодом, написанных под linux. Среди них:
\begin{itemize}
    \item ISC dhcp server
    \item KEA dhcp server
    \item udhcp
\end{itemize}

Однако ни один из них не получится использовать, так как в МД в качестве операционной системы используется eCos.

Данная ситуация оставляет только два пути:

\begin{itemize}
    \item Взять один из DHCP серверов с открытым исходным кодом и портировать.
    \item Написать DHCP сервер с нуля.
\end{itemize}

При портировании придётся потратить много времени на чтение кода.
Также при изменении функциональных требований будет сложнее модифицировать код.

Код сервера udhcp достаточно простой, но он недостаточно гибко конфигурируется.

Модель многозадачности в МД не такая как в линуксе.
В линуксе ядро может прервать процесс, в МД процесс должен сам завершится.
Данный факт также усложнит портирование.

При наисании с нуля будет полное понимание написанного кода, что само по себе является плюсом, а также позволит быстрее реагировать на измениние функциональных требований.

Таким образом трудозатраты на портирование и на написание с нуля будут примерно одинаковые.
Поэтому был сделан выбор в пользу написания с нуля, потому что в таком случае будет полное понимание написанного кода.

\subsection{Требования к разрабатываемым модулям}

\subsubsection{Реализация протокола DHCP в соответствии с RFC2131.}
\begin{itemize}
    \item Прослушивание сети на наличие DHCP запросов.
    \item Присвоение настроек хоста на основе заданных администратором параметров.
    \item Отправка ответа с присвоенными настройками.
\end{itemize}

Поддержка следующих опций
\begin{description}
    \item[2] Time Offset
    \item[3] Router
    \item[4] Time server
    \item[5] Name server
    \item[6] Domain name server
    \item[7] Log server
    \item[8] Cookie server
    \item[9] LPR server
    \item[10] Impress server
    \item[11] Resource location server
    \item[12] Host name
    \item[13] Boot file size
    \item[14] Merit dump file
    \item[15] Domain name
    \item[16] Swap server
    \item[17] Root path
    \item[18] Extentions path
    \item[19] IP forwarding enable/disable
    \item[20] Non-local source routing enable/disable
    \item[21] Policy filter
    \item[22] Maximum datagram reassembly size
    \item[23] Default IP time to live
    \item[24] Path MTU aging timeout
    \item[25] Path MTU Plateau Table
    \item[26] Interface MTU
    \item[27] All subnets are local
    \item[28] Broadcast Address
    \item[29] Perform mask discovery
    \item[30] Mask supplier
    \item[31] Perform router discovery
    \item[32] Router solicitation address
    \item[33] Static route
    \item[34] Trailer encapsulation
    \item[35] ARP cache timeout
    \item[36] Ethernet encapsulation option
    \item[37] TCP default TTL
    \item[38] TCP keepalive interval
    \item[39] TCP keepalive garbage
    \item[40] Network Information service domain
    \item[41] Network Information servers
    \item[42] Network time protocol servers
    \item[43, 60] Vendor specific Information, Vendor class identifier
    \item[44] NetBIOS over TCP/IP name server
    \item[45] NetBIOS over TCP/IP datagram distribution server
    \item[46] NetBIOS over TCP/IP node type
    \item[47] NetBIOS over TCP/IP scope
    \item[48] X window system font server
    \item[49] X window system display manager
    \item[64] Network Information service+ domain
    \item[65] Network Information service+ servers
    \item[68] Mobile IP home agent
    \item[69] Simple Mail Transport Protocol (SMTP) server
    \item[70] Post Office Protocol (POP3) server
    \item[71] Network news Transport Protocol (NNTP) server
    \item[72] Default world wide web (www) server
    \item[73] Default finger server
    \item[74] Default Internet relay chat (IRC) server
    \item[75] StreetTalk Server
    \item[76] StreetTalk directory assistance (STDA) server
    \item[66] TFTP server name
    \item[67] Bootfile name
    \item[121] Classless route
    \item[118] Subnet selection
    \item[93, 94, 97] PXE options
\end{description}

Перечисленные выше опции необходимо разбить на группы по их назначению.

\begin{itemize}
    \item Параметры канального уровня.
        \subitem Время жизни ARP \textcolor{red}{кэша} (ARP cache timeout).
        \subitem Тип Ethernet инкапсуляции, RFC894 или RFC1042.
    \item Параметры IP, спцеифичные для \textcolor{red}{хоста}.
        \subitem пересылка (forwarding).
        \subitem Пересылка пакетов с нелокальными раршрутами (non local source routing).
        \subitem Максимальный размер собираемого сообщения (maximum datagram reassembly size).
        \subitem Время жизни пакета по умолчанию (TTL).
        \subitem Время устаревания MTU пути (Path MTU aging timeout).
        \subitem Фильтры нелокальной маршутизации (policy filter).
        \subitem Размеры MTU для поиска MTU пути (Path MTU plateau).
    \item Параметры IP, специфичные для интерфейса.
        \subitem Значение MTU для интерфейса.
        \subitem У всех подключенных подсетей такое же MTU (all subnets are local).
        \subitem Выполнять определение маски подсети (perform mask discovery).
        \subitem Отвечать на ICMP запросы маски подсети (mask supplier).
        \subitem Выполнять поиск маршрутов способом определённым в RFC1256 (perform router discovery).
        \subitem Адрес запросов обнаружения маршутизаторов (router solicitation address).
    \item Параметры TCP.
        \subitem Время жизни TCP пакетов по умолчанию (default TCP TTL).
        \subitem Интервал передачи сообщения TCP keepalive.
        \subitem Передавать сообщения TCP keepalive с "garbage" октетом для обратной совместимости.
    \item Параметры различных приложений и служб.
        \subitem Смещение времени подсети клиента от \textcolor{red}{UTC}.
        \subitem Размер загрузочного файла (boot file size).
        \subitem Следующий сервер (Next bootstrap server).
        \subitem Путь файла для \textcolor{red}{дампа памяти} клиента в случае отказа (merit dump file).
        \subitem Доменное имя.
        \subitem IP адрес сервера с файлом подкачки (Swap server).
        \subitem Путь к корневому диску (root path).
        \subitem Доступный по TFTP файл с расширениями производителя (extensions path).
        \subitem Имя домена NIS.
        \subitem Тип узла NetBIOS (NetBIOS node type).
        \subitem NetBIOS scope в соответствии с RFC1001, RFC1002.
        \subitem Имя домена NIS+.
        \subitem Имя загрузочного файла.
    \item Адреса прикладных серверов.
        \subitem адреса TFTP серверов.
        \subitem адреса DNS серверов.
        \subitem адреса серверов времени (time servers, RFC868).
        \subitem адреса серверов протоколирования MIT-LCS (log servers).
        \subitem адреса cookie серверов (RFC865).
        \subitem адреса серверов печати (RFC1179).
        \subitem адреса серверов Imagen Impress.
        \subitem адреса серверов Resource Location (RFC887).
        \subitem адреса NIS серверов.
        \subitem адреса NTP серверов.
        \subitem адреса серверов NetBIOS datagram distribution.
        \subitem адреса серверов шрифтов (X window system font servers).
        \subitem адреса менеджеров X window system display.
        \subitem адреса серверов NIS+.
        \subitem адреса домашних IP агентов (mobile IP home agent).
        \subitem адреса серверов SMTP.
        \subitem адреса серверов POP3.
        \subitem адреса серверов NNTP.
        \subitem адреса серверов WWW.
        \subitem адреса серверов Finger.
        \subitem адреса серверов IRC.
        \subitem адреса серверов streettalk.
        \subitem адреса серверов STDA.
\end{itemize}

У администратора должна быть возможность создавать множество экземпляров каждой из выше перечисленных групп и присваивать им имена.
Затем, при создании конфигураций на созданные группы нужно будет ссылаться с помощью заданных имён.
Таким образом администратор будет экономить время, так как он один раз создав экземпляры групп, не прописывает заного все параметры.

Помимо перечисленных выше опций, необходимо реализовать отправку опций расширений производителя (vendor extensions).
Механизм их конфигурирования будет более сложный.
\begin {itemize}
    \item Создание именованных опций.
    \item Создание групп опций.
    \item Распределение опций по группам (одна опция может быть в нескольких группах одновременно).
    \item Создание ссылок на группы в параметрах клиента (разные клиенты могут ссылаться на одну группу).
\end{itemize}

Таким образом у каждого клиента может быть несколько опций (вся группа опций).

Однако не все опции из группы нужно отправлять клиенту. Выбор из сконфигурированных опций должен происходить на основе значения пришедшей опции класса производителя (vendor class identifier). Для этого в именованных опциях нужно помимо значения и имени добавить третье поле - класс производителя.



\subsubsection{Классификация клиентов}

Помимо создания именованных групп, у администратора также должна быть возможность создавать именованные классы.
Класс в данном контексте - это множество правил проверки пакета.
Если пришедший пакет подходит под все правила, пакету присваивается данный класс.
Пришедшему пакету могут быть присвоены несколько классов одновременно.

Поля или опции, для которых должна быть возможность определять правила:

\begin{itemize}
    \item идентификатор DHCP клиента.
    \item класс клиента (такая опция).
    \item mac адрес клиента.
    \item подопция remote id.
    \item подопция circuit id.
    \item идентификатор поставщика (vendor identifier).
\end{itemize}


\subsubsection{Подсети}

Администратор должен иметь возможность создавать подсети.
Это такие объекты, в которых есть адрес, маска и параметры клиента.
Параметры клиента - это множество ссылок на группы, по одной на группу (группы были описаны выше).

Для каждого пришедшего запроса необходимо определять его подсеть.
Подсеть должна искаться среди сконфигурированных администратором правилом наибольшего совпадения c одним из следующих полей/опций пришедшего пакета (в порядке приоритета):

\begin{itemize}
    \item link selection suboption
    \item subnet selection option
    \item поле giaddr
    \item IP адрес входного интерфейса
\end{itemize}

В каждой подсети от должно быть множество непересекающихся диапозонов IP адресов. В каждом таком диапозоне должен быть свой объект параметров.

Для того, чтобы выбрать, на основе какого из диапозонов присваивать IP адрес и конфигурацию клиенту, необходимо в каждом из диапозонов задавать правила попадания.

Как раз в тут и будут использованы классы, описанные выше.
У каждого диапазона будет два списка: список имён разрешенных и запрещённых классов.

\subsubsection{Статически выдаваемые IP адреса}

Помимо динамически выдаваемых адресов, должна быть возможность выдавать один и тот же адрес какому-то определённому компьютеру.
Локализация клиента должна происходить путём сравнения поля chaddr в заголовке, или же опции идентификатора клиента.

Маска подсети должна находится путём поиска наибольшего совпадения заданного статического IP адреса со всеми настроенными подсетями.


\pagebreak
\subsection{Архитектура}

\begin{figure}[H]
    \includegraphics[width=\textwidth]{build/second.png}
    \caption{}
    \label{fig:arch}
\end{figure}

На рисунке \ref{fig:arch} представлена часть архитектуры, в которой показывается \textcolor{red}{взаимодействие DHCP сервера с остальным проектом}.

\begin{figure}[H]
    \includegraphics[width=\textwidth]{build/packet-view.png}
    \caption{}
    \label{fig:packet-view}
\end{figure}

На рисунке \ref{fig:packet-view} показана часть архитектуры, отвечающая за \textcolor{red}{парсинг}, изменение и формирование DHCP пакетов. DHCP пакеты невозможно \textcolor{red}{распарсить} путём простого преобразования указателей. Так как помимо заголовка в них содержится вторая часть с опциями.

Большинство опций состоят из трёх, подряд идущих частей:
\begin{itemize}
    \item Идентификатор.
    \item Длина.
    \item Данные.
\end{itemize}
Поля Идентификатор и длина всегда размера 1 байт, Размер же данных указан в поле "Длина".

Однако есть две опции, состоящие только из идентификатора. Это:
\begin{itemize}
    \item Опция выравнивания (Pad Option).
    \item Опция конца (End Option).
\end{itemize}

Обрабатывает выше описанную логику класс Dhcp::Options\_editor. Однако на этом \textcolor{red}{парсинг} не заканчиватется.

Каждая опция имеет свой формат поля "Данные". В некоторых опциях в этом поле содержится, например только один IP адрес. В таких опциях длина всегда будет равна четырём. В других опциях может быть, например, строка переменной длины. Такжи бывают опции с переменным количеством IP адресов. Длина в таких случаях кратна четырём.

Класс Options\_view, на этапе компиляции сопоставляет идентификатор опции со способом расположения данных внутри неё. Использование этого класса позволяет отловить ошибки подстановки не того идентификатора опции ещё до запуска программы.

Однако и на этом \textcolor{red}{парсинг} не заканчивается.
Поля sname и file в заголовке DHCP пакета могут быть использованы не только по прямому назначению. С помощью специальной опции, каждое из них может быть перегружено, для использования под хранение опций.

Класс All\_options\_view как раз инкапсулирует в себе эту логику, и представляет такой же, как и класс Dhcp::Options\_view интерфейс.

Некоторые опции имеют сложную внутреннюю структуру. Для таких опций были написаны специальные классы, инкапсулирующие внутри себя \textcolor{red}{парсинг}, и предоставляющие методы для удобного получения данных внутри них.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{build/complex-options.png}
    \caption{Классы для опций со сложной внутренней структурой}
    \label{fig:complex_options}
\end{figure}

\begin{figure}[H]
    \includegraphics[width=\textwidth]{build/dhcp-configurator.png}
    \caption{}
    \label{fig:profiles}
\end{figure}

На рисунке \ref{fig:profiles} изображена часть архитектуры, отвечающая за группировку опций.
Видно, что класс Dhcp::Params содержит указатели на каждую из групп. Таким образом реализована возможность выбора одних и тех же опций в различных экземплярах этого класса.

\begin{figure}[H]
    \includegraphics[width=\textwidth]{build/pool.png}
    \caption{}
    \label{fig:pool}
\end{figure}

На рисунке \ref{fig:pool} изображена часть архитектуры, в которой содержится логика классификации клиентов, и присваивании нужной конфигурации.

Класс Dhcp::Permit\_list является связующим звеном.
Сначала происходит классификация клиента - формирование списка классов, к нему подходящих.
Далее, при выборе нужной конфигурации (экземпляра класса Dhcp::Range), ищется тот, в котором совподает хотя бы один из классов из поля allow, и не совподает ни один из классов из поля deny.

\begin{figure}[H]
    \includegraphics[width=\textwidth]{build/address-allocator.png}
    \caption{}
    \label{fig:address_allocator}
\end{figure}

На рисунке \ref{fig:address_allocator} изображена часть архитектуры, ответственная за хранение присвоенных, а также предложенных клиентам адресов.
Класс для защиты от атак исчерпания адресов (address exhaustion), и атак подмены MAC адреса (MAC spoofing) тоже на этом рисунке (называется Mac\_and\_remote\_id).

Как видно на рисунке, в классе Dhcp::Lease содержится поле remote\_id. Это поле используется для подсчёта экземпляров класса Dhcp::Lease. Если их оказывается слишком много, запись о возможной атаке исчерпания адресов появляется в журнале. Это помогает бороться с атаками исчерпания адресов.

Множество экземпляров Mac\_and\_remote\_id нужны для того, чтобы контролировать, из какой сети пришёл пакет с данным MAC адресом.
С их помощью можно обнаружить атаку подмены MAC адреса, когда из разных подсетей придут пакеты с одним MAC адресом.

Нужно понимать, что поддержки этого механизма со стороны сервера недостаточно, чтобы противостоять различным атакам. Более подробно про это написано в RFC3046.

\begin{figure}[H]
    \includegraphics[width=\textwidth]{build/pinger.png}
    \caption{}
    \label{fig:pinger}
\end{figure}

На рисунке \ref{fig:pinger} описана часть архитектуры DCHP сервера, отвечающая за проверку, использеутся ли  кем то другим IP адрес, который DHCP сервер собирается выдать. Проверка реализована, способом, описанным в RFC2131, то есть путём отправки на проверяемый адрес ICMP запросов, и ожидания ответов.

Как видно на рисунке, реализовано это в виде отдельного модуля. Однако, что интересно заметить, этот модуль не имеет своего объекта управления. Конфигурирование же происходит через объект управления DHCP сервера.

Несмотря на то, что изначально DHCP сервер планировалось реализовать в виде одного модуля и одного объекта управления, в ходе разработки выяснилось, что вынос описанной выше функциональности в отдельный модуль увеличит читаемость кода, так как обработка DHCP запросов и ICMP ответов будут описаны в разных местах, независимо друг от друга. Так же появится возможность переиспользования модуля Pinger.

Поэтому было принято решение скорректировать первоначальные планы, и реализовать DHCP сервер в виде двух модулей и одного объекта управления.

\pagebreak
\subsection{Тестирование}

Для тестирования были написаны Unit-тесты, с помощью библиотеки googletest.
Помимо них был написан python скрипт для эмуляции DHCP клиентов.

В нём использовался линуксовый механизм сетевых пространств имён.

Были созданы пространства имён, соединены с помощью виртуальных сетевых интерфейсов (veth pair). В каждом из них был запущен либо DHCP клиент от ISC либо DHCP ретранслятор тоже от ISC.

Это дало возможность тестировать на одном компьютере, в близких к реальным условиям.

\includegraphics[width=\textwidth]{build/test-emu.png}

\pagebreak
\section{Заключение}

В результате работы был реализован полноценный DHCP сервер.
Он соответствет RFC2131, а поэтому может работать в любых сетях, поддерживающих стандарт DHCP.

Сначала планировалось, что DHCP сервер будет реализован в виде двух компонентов уже имеющиейся системы. Однако в ходе разработки выяснилось, что с точки зрения читаемости и переиспользования кода, лучше будет реализовать DHCP сервер в виде трёх компонентов, что и было сделано.

Конфигурация сетей, использовавших DHCP ретранслятор в МД в связке с отдельным компьютером с запущенным DHCP сервером упроститься путём отказа от дополнительного компьютера переноса настроек DHCP сервера на МД.

Помимо стандарта DHCP, описанного в RFC2131, разработанный сервер так же соответствует RFC3011, RFC3442, RFC4578, RFC2132, RFC3256, RFC3527, что позволяет более точно настраивать клиенты, также поддерживающие перечисленные стандарты.

Часть кода покрыта автотестами, что сильно облегчает его дальнейшее развитие.

Сервер успешно прошел тестирование.

Обновлённое изделие прошло сертификацию ФСТЭК на соответствие требованиям, предъявляемым к межсетевым экранам и в данный момент используется в вооруженных силах Российской федерации.

Сервер планируется развивать и дорабатывать в части гибкости его настройки, а также поддержки опций GeoConf, описанных в RFC6225 и поддержки протокола RADIUS.

\end{document}
